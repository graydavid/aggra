/*
 * Copyright 2021 David Gray
 * 
 * SPDX-License-Identifier: Apache-2.0
 */

package io.github.graydavid.aggra.core;

import io.github.graydavid.aggra.core.Behaviors.BehaviorWithCustomCancelAction;
import io.github.graydavid.aggra.core.DependencyCallingDevices.DependencyCallingDevice;
import io.github.graydavid.aggra.core.Node.CommunalBuilder;

/**
 * Describes the hooks that a given Node has for responding to GraphCall, MemoryCall, and Reply signals. See
 * {@link Node#call(Caller, Memory, GraphCall, CallObservers.Observer)} for more info on cancellation signal, trigger,
 * and hook definitions.
 */
public enum CancelMode {
    /**
     * The default CancelMode that every Node has (unless they specifically declare something more complicated). This
     * mode means the Node is passively responsive to GraphCall and MemoryScope signals both before and after priming
     * dependencies (but always before running the Node's behavior).
     * 
     * @apiNote this value is *not* passively responsive to the Reply signal at all. That's a cost vs. benefit decision.
     *          Technically, all Nodes *could* be responsive to the Reply signal. This would be applicable only during
     *          the "After dependencies have finished priming but before running the behavior" hook. From the notes on
     *          {@link DependencyCallingDevice#ignore(Reply)}, the Reply signal would only ever be triggered,
     *          practically speaking, if the single consumer call invoking "ignore" was the only consumer call there
     *          was. So, in order for a consumer to trigger the signal for the hook, the same consumer call would have
     *          to call the dependency and then ignore it before the dependency was finished with priming. I consider
     *          that to be an edgecase. Meanwhile, the cost of supporting Reply signal triggering for every node would
     *          be 1 additional volatile read per every time the hook was triggered. I don't think the cost is worth it.
     * 
     *          Alternatively, the user could upgrade to {@link #COMPOSITE_SIGNAL}, which is passively responsive to the
     *          Reply signal, and retroactively get this capability for free, even if they never used the composite
     *          signal internally in the Behavior. A downside of this alternative is that users can't use common Nodes
     *          created with factories that don't use composite signals. An alternative there would be to create a new
     *          Memory for the common Node and its consumer and rely on the MemoryScope signal instead. If none of this
     *          works, or there's an overwhelming desire from clients to provide first-class support, then it would be
     *          possible to modify Aggra to insert a new CancelMode between DEFAULT and COMPOSITE_SIGNAL, called
     *          something like REPLY_SIGNAL_PASSIVE_HOOK. Then, we could add a new build method to
     *          {@link CommunalBuilder} and modify common Node factories to support that.
     */
    DEFAULT(false, false, false),
    /**
     * Has the same capabilities as {@link #DEFAULT} in addition to providing access to a composite cancel signal to the
     * Node's behavior. This composite cancel signal is a combination of the relevant GraphCall, MemoryScope, and Reply
     * cancel signals relative to the Node. The Node's behavior can passively poll this composite signal and decide for
     * itself what to do from that.
     */
    COMPOSITE_SIGNAL(true, false, false),
    /**
     * Has the same capabilities as {@link #COMPOSITE_SIGNAL} in addition to executing a custom, user provided action in
     * response to any cancel signal. Once a relevant cancel signal is triggered, the Aggra framework executes this
     * action either immediately, if the Node's behavior has already started running, or as soon as the Node's behavior
     * starts running, if it already hasn't. This assumes that passive hooks haven't already resulted in the Reply's
     * cancellation, preventing the behavior from running at all, which if true, means the custom action is never run.
     * This also assumes that the associated Reply is not already finished, in which case the custom action may never be
     * run either. Either way, Aggra will run the custom action a maximum of once.
     */
    CUSTOM_ACTION(true, true, false),
    /**
     * Has the same capabilities as {@link #CUSTOM_ACTION} in addition to supporting interrupts (i.e.
     * {@link Thread#interrupt()}) for the custom action. Supporting this feature means that the Aggra framework will
     * make sure that any interrupt generated by the custom action is received during the running of the Behavior, as
     * described thoroughly in {@link BehaviorWithCustomCancelAction#cancelActionMayInterruptIfRunning()}.
     */
    INTERRUPT(true, true, true);

    private final boolean supportsReplySignalPassiveHook;
    private final boolean supportsCustomAction;
    private final boolean supportsCustomActionInterrupt;

    CancelMode(boolean supportsReplySignalPassiveHook, boolean supportsCustomAction,
            boolean supportsCustomActionInterrupt) {
        this.supportsReplySignalPassiveHook = supportsReplySignalPassiveHook;
        this.supportsCustomAction = supportsCustomAction;
        this.supportsCustomActionInterrupt = supportsCustomActionInterrupt;
    }

    /**
     * Does this mode support the Reply cancellation signal's passive hook? This hook is only relevant in
     * {@link #COMPOSITE_SIGNAL} and beyond. Currently just a synonym for {@link #supportsCompositeSignal()}, since all
     * CancelModes support the GraphCall and MemoryScope cancellation signals, but this theoretically *could* be
     * different.
     */
    boolean supportsReplySignalPassiveHook() {
        return supportsReplySignalPassiveHook;
    }

    /** Does this mode support the composite cancel signal? */
    public boolean supportsCompositeSignal() {
        return supportsReplySignalPassiveHook();
    }

    /**
     * Does this mode support any active hooks? Currently just a synonym for {@link #supportsCustomAction()}, since
     * that's the only active hook right now, but this theoretically *could* be different.
     */
    boolean supportsActiveHooks() {
        return supportsCustomAction();
    }

    /** Does this mode support custom actions run during cancellation? */
    public boolean supportsCustomAction() {
        return supportsCustomAction;
    }

    /** Does this mode support interrupts generated by the custom action? */
    public boolean supportsCustomActionInterrupt() {
        return supportsCustomActionInterrupt;
    }
}
